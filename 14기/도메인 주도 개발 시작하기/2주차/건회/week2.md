# 3.애그리거트

## 3.1 애그리거트

주요 도메인 요소 간의 관계 파악이 어렵다 === 코드 변경&확장이 어렵다

- 상위 수준에서 모델을 조망할 수 있는 방법
- 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만든 것
- 유사하거나 동일한 라이프 사이클을 가짐
- 경계를 가지며 경계 외부의 애그리거트는 관리하지 않음

## 3.2 애그리거트 루트

- 루트 엔티티
- 애그리거트 전체를 관리할 주체
- 애그리거트의 일관성이 깨지지 않도록 해줌

### 3.2.1 도메인 규칙과 일관성

- 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다.
- 응용 서비스 같은 곳에서 할 수도 있지만 그렇게 될 경우, 중복이 많이 생기거나 일관성이 깨지게 됌

### 3.2.2 애그리루트의 기능 구현

- 애그리거트 루트가 내부의 다른 객체를 조합해서 기능을 완성
- 내부 객체에 대해 외부 접근이나 상태 변경이 가능하게 하면 일관성이 깨질 수 있음
- 불변으로 구현하거나 protected 접근 제한

### 3.3.3 트랜잭션 범위

- 작을수록 좋다
- 한 트랜잭션 안에 한 개의 애그리거트만 수정해야한다.

## 3.3 리포지터리와 애그리거트

- 테이블 별로 리포지토리를 항상 각각 만들지는 않는다.
- 리포지토리 메소드는 완전한 애그리거트를 제공해야한다

## 3.4 ID를 이용한 애그리거트 참조

- 다른 애그리거트를 참조한다 === 다른 애그리거트 루트를 참조한다
- 발생할 수 있는 문제
  - 한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 결합도가 높아져 변경이 어려워진다
  - 성능 이슈가 생길 수 있다
  - 확장이 어려워진다
- → Id만 참조
- 애그리거트가 필요하면 서비스에서 Id로 로딩
- N+1문제는 별도의 DAO나 조회전용쿼리로 해결

## 3.5 애그리거트 간 집합 연관

- 개념적으로 1:N/M:N 관계이더라도 성능 이슈가 있을 수 있어 실제 구현에 반영하지 않는다.

## 3.6 애그리거트를 팩토리로 사용

# 4. 리포지토리와 모델 구현

### 4.1 리포지토리 구현

- 인터페이스는 애그리거트 루트를 기준으로 작성

### 4.3 매핑 구현

- typeorm 이면 entity를 그대로 활용해야하나?
- embeddEntity
- 밸류 타입으로 식별자 구현
  - 식별자에 기능을 추가할 수 있다.
  - typeOrm이라면?
- 별도 테이블에 저장한다고 엔티티인 것은 아니다
  - ex) OrderLine(엔티티X, 밸류O)
  - 자신만의 독자적인 라이프 사이클을 가짐 → 별개의 애그리거트
- 개념적으로 밸류지만 엔티티를 사용할 때가 있음

## 4.4 애그리거트 로딩 전략

- 애그리거트 루트를 로딩 → 루트에 속한 모든 객체가 완전한 상태여야함
  1. 상태 변경 시 애그리거트의 상태가 완전해야해서
  2. 표현 영역에서 애그리거트의 상태를 보여줘야힉 때문에
- 루트 로딩 시점에 모두 로딩해야하는 것은 아님
-

## 4.6 식별자 생성 기능

- 식별자에 생성 규칙
  - 도메인 규칙이므로 도메인 영역에 위치해야함
  - 별도 서비스로 식별자 생성 기능 분리 필요

## 4.7 도메인 구현과 DIP

- DIP는 개발 편의성과 실용성을 위해 구조적 유연함을 가져갈 필요가 있다.
